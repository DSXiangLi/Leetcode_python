- 常规问题
  - 62 不同路径: $dp[i][j] = dp[i-1][j] + dp[i][j-1]$
  - 63 不同路径 II : 同上，碰到障碍保持0
  - 64 最小路径和：$ dp[i][j] = min(dp[i-1][j],dp[i][j-1])+ grid[i$][j]
  - 70 爬楼梯：$dp[n] = dp[n-1]+dp[n-2] $，长度是n
  - 343 整数拆分: $dp[i] = max(dp[i-j]*j, (i-j)*j)$，拆分or不拆分
  - 509 斐波那契数 : $dp[n] = dp[n-1]+dp[n-2] $, 长度是n+1 
  - 746 使用最小花费爬楼梯:$dp[i] = min(dp[i-2], dp[i-1]) + cost[i]$, 最后返回$min(dp[-1],dp[-2])$
  - 198 打家劫舍 $dp[i] = max(dp[i-1], dp[i-2]+nums[i-1])$
  - 213 打家劫舍 II: 首尾相连，去除首/尾做两次计算
  - 337 打家劫舍 III：dfs返回打劫/不打劫当前节点的两个rob数值
  
- 0/1背包：不能重复使用元素倒序背包
  
  - 问题可以被分成： 求和，计数，是否存在组合，最大/最小组合数，组合数/排列数
  - 416 分割等和子集
    - 求和，全0初始化，内外皆可，$dp[j] = max(dp[j], dp[j-n]+n)$
  - 474 一和零
    - 计数，全0初始化，背包内物品外，$dp[i]=dp[i-cost]+1$
  - 494 目标和
    - 组合数=target， dp[0]=1，背包内物品外，$dp[i]+=dp[i-n]$
  - 1049 最后一块石头的重量 II
    - 求和，全0初始化，内外皆可，$dp[i] = max(dp[i], dp[i-s]+s)$
  
- 完全背包：可以重复使用元素正序背包
  - 139 单词拆分
    - 是否存在排列，dp[0]=True，背包外物品内，value=True, cost=单词匹配 dp[i]=dp[i] or (dp[i-cost] & is_s)
  - 279 完全平方数
    - 最小组合数，dp[0]=0（剩余位置最大化），物品外背包内， $dp[i] = min(dp[i], dp[i-num**2]+1)$
  - 322 零钱兑换
    - 最小组合数，dp[0]=0(剩余位置最大化)，物品外背包内，$dp[i] = min(dp[i-coin]+1, dp[i])$
  - 377 组合总和 Ⅳ
    - 组合数=target，dp[0]=1，物品外背包内，$ dp[i] +=dp[i-n]$
  - 518 零钱兑换 II
    - 组合数=target，dp[0]=1，物品外背包内，$dp[i] +=dp[i-c]$

- 买卖股票
  - 122 买卖股票的最佳时机 II：无数次
  - 123 买卖股票的最佳时机 III: 2次
  - 188 买卖股票的最佳时机 IV：k次
  - 309 最佳买卖股票时机含冷冻期：把不持有状态区分成T，T-1,<T-2
  - 714 买卖股票的最佳时机含手续费：持有收益考虑fee

- 子序列
  - 72 编辑距离
    - 和583相比增加替换操作，相同$dp[i][j]=dp[i-1][j-1]$, 不同$dp[i][j] = min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])+1$
  - 97 交错字符串
    - $dp[i][j] = (dp[i-1][j] and s1[i-1]==s3[pos]) or (dp[i][j-1] and s2[j-1]==s3[pos])$
  - 115 不同的子序列
    - 相同：$dp[i][j] = dp[i-1][j] + dp[i-1][j-1]$, 不同$dp[i][j] = dp[i-1][j]$
  - 300 最长递增子序列: 
    - $dp[i] = max(dp[i], dp[j]+1)$,注意初始化都是1，且需要全局maxlen
  - 392 判断子序列:
    -  只有删除操作，相同$dp[i][j] =dp[i-1][j-1]+1$, 不同$dp[i][j] = dp[i][j-1]$, 判断最后长度是否为s
  - 516 最长回文子序列：
    - 相同$dp[i][j]=dp[i+1][j-1]+2$，不同$dp[i][j] = max(dp[i+1][j], dp[i][j-1])$,左下到右上的遍历方式
  - 583 两个字符串的删除操作
    - 和392相比是双向删除，注意初始化是序列长度，相同$dp[i][j]=dp[i-1][j-1]$, 不同$dp[i][j] = min(dp[i][j-1],dp[i-1][j])+1$
  - 718 最长重复子数组：
    - 连续子序列$ dp[i][j] = dp[i-1][j-1]+1$，需要全局maxlen
  - 1035 不相交的线：和1143相同
  - 1143 最长公共子序列：
    - 不连续的子序列，相同$ dp[i][j] = dp[i-1][j-1]+1$ ，不同$dp[i][j] = max(dp[i-1][j], dp[i][j-1])$，最大长度一定是最后一位

  

